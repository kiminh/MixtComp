/*--------------------------------------------------------------------*/
/*  Copyright (C) Inria 2015

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 *  Project:    MixtComp
 *  Created on: March 24, 2015
 *  Author:     Vincent KUBICKI <vincent.kubicki@inria.fr>
 **/

#include "gtest/gtest.h"
#include "../../src/mixt_MixtComp.h"

using namespace mixt;

/**
 * Simple case with two modalities
 */
TEST(BOSPath, computeLogProba0)
{
  int mu = 1; // mode
  Real pi = 0.5; // precision

  BOSPath path;
  path.setInit(0, 1);
  path.setEnd(0, 1);

  path.c_(0).y_ = 1; // second element y picked, proba 0.5
  path.c_(0).z_ = 1; // comparison is perfect, proba 0.5
  path.c_(0).partition(path.eInit_); // computation of the partition
  path.c_(0).e_ << 1, 1; // segment is {1}, proba 1.

  Real expectedProba = std::log(0.5 * 0.5 * 1.);
  Real computedProba = path.computeLogProba(mu,
                                 pi);

  ASSERT_LT(std::abs(expectedProba - computedProba), epsilon);
}

/**
 * Simple case with three modalities and imprecision
 */
TEST(BOSPath, computeLogProba1)
{
  int mu = 1; // mode
  Real pi = 0.5; // precision

  BOSPath path;
  path.setInit(0, 2);
  path.setEnd(0, 0);

  path.c_(0).y_ = 1; // y, middle element y picked, proba 1./3.
  path.c_(0).z_ = 0; // z, comparison is imperfect, proba 0.5
  path.c_(0).partition(path.eInit_); // computation of the partition
  path.c_(0).e_ << 0, 0; // e, left segment {0, 0} selected, proba 0.33 (all have the same size)

  path.c_(1).y_ = 0; // y, only one element to choose from, proba 1.
  path.c_(1).z_ = 1; // z, comparison is perfect, proba 0.5
  path.c_(1).partition(path.c_(0).e_); // computation of the partition
  path.c_(1).e_ << 0, 0; // e, only one segment in partition, with proba 1.

  Real expectedProba = std::log(1./3. * 0.5 * 1./3. *
                                1.    * 0.5 * 1.);
  Real computedProba = path.computeLogProba(mu, pi);

#ifdef MC_DEBUG
  std::cout << "expectedProba: " << expectedProba << std::endl;
  std::cout << "proba: " << computedProba << std::endl;
#endif
  ASSERT_LT(std::abs(expectedProba - computedProba), epsilon);
}

/**
 * Multiple Tests of the initialization, using the piInitBos used in initialisation
 */
TEST(BOSPath, initPath)
{
  BOSPath path;
  int nbTest = 10000;
  MultinomialStatistic multi;

  bool validPath = true;
  bool zeroZ = true;
  bool nonNulProba = true;

  for (int i = 0; i < nbTest; ++i)
  {
    int ini0 = multi.sampleInt(0       , 9   );
    int ini1 = multi.sampleInt(ini0 + 1, 10  );
    int end0 = multi.sampleInt(ini0    , ini1);
    int end1 = multi.sampleInt(end0    , ini1);

    int mu = multi.sampleInt(ini0, ini1);

    path.setInit(ini0, ini1);
    path.setEnd (end0, end1);

    path.initPath();

    if (!(path.endCond_(0)                <= path.c_(path.nbNode_ - 1).e_(0) &&
        path.c_(path.nbNode_ - 1).e_(0) <= path.endCond_(1)                    ))
    {
      validPath = false;
    }

    Real logProba = path.computeLogProba(mu, piInitBOS);
    if (logProba == minInf)
    {
#ifdef MC_DEBUG
      std::cout << "logProba: " << logProba << std::endl;
#endif
      nonNulProba = false;
    }

    if (path.nbZ() > 0)
    {
      zeroZ = false;
    }
  }

  ASSERT_EQ(validPath, true); // are all path generated valid ?
  ASSERT_EQ(zeroZ, true); // are all z been initialized to 0 ?
  ASSERT_EQ(nonNulProba, true); // do they all have a non zero probability ?
}

/**
 * test the probability distribution generated by arbitrary BOS parameters.
 */
TEST(BOSPath, ArbitraryGibbs)
{
  MultinomialStatistic multi;
  UniformStatistic uni;
  int nbIterBurnIn = 500;
  int nbIterRun    = 500;

  int iniMin = 0;
  int iniMax = 4;

//  int minCond = multi.sampleInt(0      , initSeg(1));
//  int maxCond = multi.sampleInt(minCond, initSeg(1));
  int endMin = iniMin;
  int endMax = iniMax;

  BOSPath path;
  path.setInit(iniMin, iniMax);
  path.setEnd (endMin, endMax);

  bool correctExpectedMode = true;

  for (int mu = endMin; mu <= iniMax; ++mu)
  {
    path.initPath();
  #ifdef MC_DEBUG
    std::cout << "initialization, displayPath(path)" << std::endl;
    displayPath(path);
  #endif

    Vector<Real> computedProba(iniMax - iniMin + 1);
    computedProba = 0.;
    int computedMode;

    Real pi = 0.5;

    int expectedMode = std::max(mu, endMin);
    expectedMode = std::min(expectedMode, endMax);

  #ifdef MC_DEBUG
    std::cout << "iniMin: " << iniMin << ", iniMax: " << iniMax << std::endl;
    std::cout << "endMin: " << endMin << ", endMax: " << endMax << std::endl;
    std::cout << "mu: " << mu << ", pi: " << pi << std::endl;
    std::cout << "expectedMode: " << expectedMode << std::endl;
  #endif

  #ifdef MC_DEBUG
    std::cout << "Initial path, displayPath: " << std::endl;
    BOSDisplayPath(path);
  #endif

    for (int iter = 0; iter < nbIterBurnIn; ++iter)
    {
  #ifdef MC_DEBUG
      std::cout << "ArbitraryGibbs, iter: " << iter << std::endl;
  #endif

      path.samplePath(mu,
                      pi,
                      sizeTupleBOS,
                      true);
    }

    for (int iter = 0; iter < nbIterRun; ++iter)
    {
  #ifdef MC_DEBUG
      std::cout << "ArbitraryGibbs, iter: " << iter << std::endl;
  #endif

      path.samplePath(mu,
                      pi,
                      sizeTupleBOS,
                      true);
      int x = path.c_(path.nbNode_-1).e_(0); // x is sampled here
      computedProba(x) += 1.; // the new occurrence of x is stored
    }

    computedProba /= computedProba.sum();
    computedProba.maxCoeff(&computedMode);

#ifdef MC_DEBUG
    std::cout << "computedProba" << std::endl;
    std::cout << computedProba << std::endl;
#endif

    if (expectedMode != computedMode)
    {
      correctExpectedMode = false;
    }
  }

  ASSERT_EQ(correctExpectedMode, true); // has the real mode been estimated correctly ?
}

/**
 * Test the probability distribution obtained from frequencies of forwardSamplePath
 */
TEST(BOSPath, forwardSamplePath)
{
  MultinomialStatistic multi;
  UniformStatistic uni;
  int nbIter = 1e4;

  int iniMin = 0;
  int iniMax = 4;

//  int minCond = multi.sampleInt(0      , initSeg(1));
//  int maxCond = multi.sampleInt(minCond, initSeg(1));
  int endMin = iniMin;
  int endMax = iniMax;

  BOSPath path;
  path.setInit(iniMin, iniMax);
  path.setEnd (endMin, endMax);

  Vector<Real> computedProba(iniMax - iniMin + 1);
  computedProba = 0.;
  int computedMode;

  int mu = multi.sampleInt(iniMin, iniMax);
  Real pi = uni.sample(0., 1.);
//  int mu = 2;
//  Real pi = 0.5;

#ifdef MC_DEBUG
  std::cout << "mu: " << mu << ", pi: " << pi << std::endl;
#endif

  Vector<bool, 2> az;
  az = true;

  for (int iter = 0; iter < nbIter; ++iter)
  {
#ifdef MC_DEBUG
    std::cout << "forwardSamplePath, iter: " << iter << std::endl;
#endif
    path.forwardSamplePath(mu,
                           pi,
                           az);
    int x = path.c_(path.nbNode_-1).e_(0); // x is sampled here
    computedProba(x) += 1.; // the new occurrence of x is stored
  }
  computedProba /= computedProba.sum();
  computedProba.maxCoeff(&computedMode);
#ifdef MC_DEBUG
  std::cout << "Final path, displayPath: " << std::endl;
  displayPath(path);
  std::cout << "computedProba" << std::endl;
  std::cout << computedProba << std::endl;
#endif

  ASSERT_EQ(mu, computedMode); // has the real mode been estimated correctly ?
}

/** pi is selected close to 1, but in forwardSamplePath all z = 0 and z = 1 cases are forbidden.
 * The test checks if all z but one are at 1 in each individual. */
TEST(BOSPath, allZOneAuthorizedForward)
{
  int nbSample = 1000;
  int nbModality = 4;
  int mu = 1;
  Real pi = 0.999; // high pi to ensure the maximum possible z = 1 nodes
  Real errorTolerance = 0.05;

  RowVector<Real> nbZ(nbSample);

  BOSPath path;
  path.setInit(0, nbModality - 1);
  path.setEnd (0, nbModality - 1); // no constraint on values

  for (int n = 0; n < nbSample; ++n)
  {
    path.forwardSamplePath(mu,
                           pi,
                           false);
    nbZ(n) = path.nbZ();

#ifdef MC_DEBUG
    std::cout << "n: " << n << std::endl;
    for (int node = 0; node < nbModality - 1; ++node)
    {
      std::cout << path.c_(node).z_ << std::endl;
    }
#endif
  }

#ifdef MC_DEBUG
  std::cout << "nbZ.mean(): " << nbZ.mean() << std::endl;
#endif

  ASSERT_LT(std::abs(nbZ.mean() - (nbModality - 2)), errorTolerance);
}

TEST(BOSPath, allZOneAuthorizedGibbs)
{
  int nbItBurnIn = 1000;
  int nbItRun = 1000;
  int nbModality = 4;
  int mu = 1;
  Real pi = 0.999; // high pi to ensure the maximum possible z = 1 nodes
  Real errorTolerance = 0.05;

  RowVector<Real> nbZ(nbItRun);

  BOSPath path;
  path.setInit(0, nbModality - 1);
  path.setEnd (0, nbModality - 1); // no constraint on values

  path.initPath(); // random init with all z = 0, to ensure a valid complete individual

  Vector<bool, 2> az;
  az = false; // individual with all z = 0 and all z = 1 are forbidden

  for (int iter = 0; iter < nbItBurnIn; ++iter)
  {
    path.samplePath(mu,
                    pi,
                    sizeTupleBOS,
                    az);
  }

  for (int iter = 0; iter < nbItRun; ++iter)
  {
    path.samplePath(mu,
                    pi,
                    sizeTupleBOS,
                    az);
    nbZ(iter) = path.nbZ();
  }

#ifdef MC_DEBUG
  std::cout << "nbZ.mean(): " << nbZ.mean() << std::endl;
#endif

  ASSERT_LT(std::abs(nbZ.mean() - (nbModality - 2)), errorTolerance);
}
