- Méthode générale
    - Conserver la méthode par template actuelle, pour ne pas avoir d'erreurs de compilation
    - Ajouter les SGraph petit à petit
    - Ajouter les fonctions de traduction std::vector<std::string> -> AugmentedData<Type>
        - Gros du code déjà dans MisValParser
    - Implémenter les bonnnes valeurs
        - En priorité les SimpleMixture, pour faire des essais plus facilement
        - Chercher dummyData, dummyParam
    - Supprimer les templates
    - pour la prédiction, fournir un SGraph param qui contient un child par variable, mais vide
- MixtureManager
    - boucle sur desc pour instancier les variables
    - activer toutes les mixtures (adapter leur code aussi, Rank et les deux Functionnal)
- JSONToSGraph
    - comment vérifier les types, par exemple que ctype est une chaîne de caractères ?
    - Eviter copies d'objects en créant d'abord le NamedVector, puis en éditant directement ses membres
    - Il doit y avoir possibilité de templater les différents NamedVector, dans le SGraphVisJSON aussi d'ailleurs
- MixtureComposer
    - supprimer les arguments redondants dans le constructeur
    - Une fois que les données ont été parsées, gData doit être vidé. Inutile de conserver les valeurs d'entrée en mémoire.
    - Sauf qu'on donne une référence sur const.
- IMixture
    - nClass et nInd doivent être des const, fournis dès la construction
    - fournir aussi le type, sous forme de chaîne de caractère, utile pour la sortie, voir https://gitlab.inria.fr/kubicki/MixtComp/blob/master/MixtComp/docs/objectOutput.md
    - Comme le SGraph a été construit, c'est une information dont on dispose dès le début de l'algorithme
    - Supprimer les nClass et nInd dans les classes dérivées de IMixture (tous l'ont pour le moment)
        - les arguments nClass et nInd seront uniquement transmis au constructeur de IMixture
    - remplacer dummyNClass et dummyNInd dans MixtureManager, par les vraies valeurs
- AugmentedData
    - supprimer tout ce qui a traît à FixedInitialization
- paramStr
    - La version fournie dans desc.json doit être fournie à la création, dans le MixtureManager
    - La version lu à partir des paramètres doit être fournie dans setDataParam, quand le SGraph de paramètres est fournie
    - Le second si il existe, en prédiction, écrase le premier
- DataHandler
    - La spécialisation pour Vector<std::string> devient inutile, les modèles devront se débrouiller avec le std::vector<std::string>, et en faire l'analyse syntaxique eux même.
- Modèle
    - chaque modèle doit fournir au constructeur IMixture une chaîne de caractère pour donner son type
- SGraph
    - l'information nInd doit figurer au même niveau que nClass, et doit servir pour vérifications. On ne doit plus déduire le nombre d'individus.
    - ajouter exist_child et exist_payload pour tester (renvoyer aussi le type si posible)
    - ajouter test d'ajout d'entrée dupliquée, et générer une exception, ça ne doit pas rester silencieux.
        - https://stackoverflow.com/questions/10732074/stl-map-allows-duplicate-pairs
    - éviter toutes les recopies actuelles
        - comme on ajoute les données dans des maps, on fait une recopie, parce que les stl utilisent des valeurs
        - idéalement il faudrait stocker les données dans des pointeurs, par exemple shared_ptr
        - faire cette modification quand tout marche, sinon ce sera trop complexe
        - localisations des retours de SGraph
            - IMixture::exportDataParam
        - dans tous les cas, c'est de l'implémentation interne, l'utilisateur ne doit pas avoir à gérer les shared_ptr, il faut toujorus renvoyer des références constantes sur l'objet contenu...
        - le soucis ce sera pour les entrées, il faudra peut être passer à la main par des make_shared
    - Créer une fonction récursive de validation
        - vérifier les ncol et nrow
        - présence de tous les champs
        - toutes les variables ont le même nombre d'individus (fourni en argument, au même titre que nClass)
        - pour les noms de lignes / colonnes, soit il y en a 0, soit il y en a autant que de ligne / colonnes. Tout autre possibilité exclue.
        - Vérifier qu'il y a au moins une variable dans desc, et que à chaque variable desc correspond une seule variable data
        - confidenceLevel < 0. || 1. < confidenceLevel
        - Dans algo, vérifier que l'utilisateur a tout fourni
        - Factoriser les fonctions de vérifications, notamment celles qui utilisent des bornes (positivité)
        - Trouver une façon de vérifier le type
    - ajouter une méthode clear(), qui permet de supprimer tout le contenu. Utili pour le SGraph de données pour gagner de la place
    - pas besoin d'extraire à la main param. Pointer vers le json de sortie de l'apprentissage, et le code extrait le SGraph correspondant aux paramètres tout seul
- Export données / param
    - ajouter les stats pour les données
        - pour les categorielles, faire comme les classes, fournir toutes les modalités sous forme de tableau, au lieu de la liste dégueu avec les 95 % comme actuellement
- Cas test
    - Créer à la main un json avec une variable décrite sur laquelle on veut estimer une loi normale, par exemple deux classes et une vingtaine d'observations générées à la main. Pour détecter les erreurs les plus flagrantes.
    - Conserver ce cas test, et se débrouiller pour pouvoir faire un test unitaire dessus, par exemple en validant le json de sortie par rapport à un résultat attendu
- json
    - vérifier que mode existe, que c'est une chaîne de caractère et qu'il vaut learn ou predict
- Optimisation
    - vérifier qu'il n'y a pas de copies de rvalue inutiles
