\documentclass[a4paper,11pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{fullpage}

% Title Page
\title{Framework Specification: Internals and Externals}

\begin{document}
\maketitle
\tableofcontents

\begin{abstract}
This is a mini-report for global architecture of MixComp. We will make use of two terms "framework" and "developer". The framework provides a unified development environment Whereas developer will refer to the coding part that will make use of the framework (without modifying the framework) to realize new mixture laws. In practice, this is just a separation of Interface (framework) and Implementation (developer).  
\end{abstract}
\section{Framework Introduction}
The idea of unified framework is to integrate the existing and future clustering models. The things that can be expected from the framework are:
\begin{enumerate}
\item Unified environment for composite mixture model based on the independence assumption.
\item Abstract(Interface) plug-in class that must be derived by developer to develop a new mixture law and data handling.
\item Facilitate creation of Rpackage, Web Interface, GUI and other High level functionalities.
\item Facilitate parallelization using distributed and shared memory models.
\item Take input from user and run the whole software.
\end{enumerate}

The developer is not expected to change the functionalities provided by this framework but can only provide concrete behavior to these functionalities. Any new functionalities should be first introduced in the framework. Hence the framework is expected to evolve with time. The developer is only expected to provide all the low level implementations needed by the framework without worrying about how these functionalities will be brought together to realize a composite mixture model. Hence in short, the developer can concentrate on development of existing and new mixture laws without worrying about how to run them in integrated(composite) environment. The developer is free to chose it's development environment (including numerical libraries for example STK++, Eigen, Lapack or anything more suitable to developer needs) and in no way will be restricted by framework. For example, a developer can re-factor their existing codes and fit them into the framework (Quentin existing codes will be a good test for it) or one can re-implement from scratch  using this framework (development of simple models including Bernoulli and Gaussian(with diagonal co-variance matrix) with Serge on STK++ platform will be a good test for it). This is the most interesting feature of this architecture as it will allow to independently develop new models. 

\section{Plug-in Specification}

Below are the Interface methods that will (hopefully) allow to develop all the kinds of existing and new mixture laws that are based on SEM-gibbs algorithm. The functions ending with "() = 0" must be defined by the developer of new mixture law. The functions ending with "() \{\}" do nothing by default and the functions ending with "()" will be implemented in framework (the developer can of-course overwrite them in some cases for performance reasons.)
\begin{itemize}
\item {\bf virtual void initializeStep(double** ) = 0} \\
This function must be use for initialization stuffs including initialize of all the parameters. The function accepts one argument for randomly initialized class labels. This method will be called only once in the very beginning. 
\item {\bf virtual void imputationStep(double* ) \{\}}\\
This function should be used for Imputation of data. The function accepts one argument for proportions.
\item {\bf virtual void samplingStep(double*,double**) = 0} \\
This function must be used for simulation of all the latent variables and/or missing data  excluding class labels. The class labels will be simulated by the framework itself because to do so we have to take into account all the mixture laws. The function accepts two arguments, one for proportions and one for class labels (or conditional probabilities).
\item {\bf virtual void paramUpdateStep(double**) = 0}\\
This function is equivalent to Mstep. The function accepts one argument for class labels (or conditional probabilities). This function must be defined by developer to update parameters. 
\item {\bf virtual void finalizeStep() \{\}}\\
This step can be used by developer to finalize any thing. It will be called only once after we finish running the SEM-gibbs algorithm.
\item {\bf virtual double posteriorProbability(int sample\_num,int Cluster\_num) = 0}\\
This function must be defined by developer to return the probability for corresponding sample and cluster. 
\item {\bf virtual double** allPosteriorProbabilties()}\\
This function will be defined in framework using {\bf posteriorProbability} function, but developer can override this function for performance reasons.
\item {\bf virtual double logLikelihood() const = 0}\\
This will return the likelihood value to be used by selection criteria.
\item {\bf virtual int freeParameters() const = 0}\\
This will be used to return number of free parameters to be used by selection criteria.
\end{itemize}

I have intentionally excluded the notion of Estep, Mstep, Sstep and Cstep to avoid any misunderstandings for the developer.  These names will be used inside the framework to make it generic enough to expand for future.    
   
\end{document}          
